#!/bin/sh -x
# Backsnap
#
# Derived from discussions on this page:
#   http://www.mikerubel.org/computers/rsync_snapshots/
#
# Configure /etc/backsnap/config
# Then run /sbin/backsnap regularly
#
# Example usage from cron:
#   0 */4 * * *    root   /sbin/backsnap
#
#-------------------------------------------------------------------------
# Avoid accidental use of $PATH
unset PATH

#-------------------------------------------------------------------------
# Verify we are running as root
THISUID=`/usr/bin/id -u`
if [ $THISUID -ne 0 ] ; then
  /bin/echo "This script will only run as root."
  exit 1
fi

#-------------------------------------------------------------------------
# Include and validate the config file
source /etc/backsnap/config

if [ 'z$SOURCE_DIRS' = 'z' ] ; then
  /bin/echo "SOURCE_DIRS not defined"
  exit 1
fi
for dr in $SOURCE_DIRS; do
  if [ ! -d $dr ] ; then
    /bin/echo "Source directory $dr not found"
    exit 1
  fi
done
if [ z$EXCLUDE_FILE = z ] ; then
  /bin/echo "EXCLUDE_FILE not defined"
  exit 1
fi
if [ ! -r $EXCLUDE_FILE ] ; then
  /bin/echo "Cannot read exclude file $EXCLUDE_FILE"
  exit 1
fi
if [ z$BACKUP_HOST = z ] ; then
  /bin/echo "BACKUP_HOST not defined"
  exit 1
fi
if [ x$BACKUP_HOST_PATH = z ] ; then
  /bin/echo "BACKUP_HOST_PATH not defined"
  exit 1
fi
if [ z$BACKUP_RSYNC_PASSWD_FILE = z ] ; then
  /bin/echo "BACKUP_RSYNC_PASSWD_FILE is not set"
  exit 1
fi
if [ ! -f $BACKUP_RSYNC_PASSWD_FILE ] ; then
  /bin/echo "$BACKUP_RSYNC_PASSWD_FILE doesn't exist"
  exit 1
fi
if [ ! -r $BACKUP_RSYNC_PASSWD_FILE ] ; then
  /bin/echo "$BACKUP_RSYNC_PASSWD_FILE cannot be read"
  exit 1
fi
if [ x$BACKUP_RSYNC_SHARE = x ] ; then
  /bin/echo "BACKUP_RSYNC_SHARE is not set"
  exit 1
fi

#-------------------------------------------------------------------------
# Determine the rotation

DOY=`/bin/date +%j`
AMOD=`/usr/bin/expr $DOY % 2`     # Every odd 1-day
BMOD=`/usr/bin/expr $DOY % 4`     # Every odd 2-day  (2, not 4, 6, not 8, ...)
CMOD=`/usr/bin/expr $DOY % 8`     # Every odd 4-day  (4, not 8, 12, ...)
DMOD=`/usr/bin/expr $DOY % 16`    # ...
EMOD=`/usr/bin/expr $DOY % 32`
FMOD=`/usr/bin/expr $DOY % 64`
GMOD=`/usr/bin/expr $DOY % 128`   # Every odd 64-day (64, not 128, ...)

# Worst case backup period is (2^(n-2)+1) days
# Best case backup period is (2^(n-1)) days
# We go up to H (n=8), so we have backups dating from
#   65 (worst case) to 128 (best case) days ago

if [ $AMOD -ne 0 ] ; then TARGET='A'
elif [ $BMOD -ne 0 ] ; then TARGET='B'
elif [ $CMOD -ne 0 ] ; then TARGET='C'
elif [ $DMOD -ne 0 ] ; then TARGET='D'
elif [ $EMOD -ne 0 ] ; then TARGET='E'
elif [ $FMOD -ne 0 ] ; then TARGET='F'
elif [ $GMOD -ne 0 ] ; then TARGET='G'
else TARGET='H';
fi

# SAFETY CHECK, BACKUP_HOST_PATH must be at least 3 characters long
BHPC=`/bin/echo ${BACKUP_HOST_PATH} | /usr/bin/wc -m`
if [ $BHPC -lt 3 ] ; then
  /bin/echo "BACKUP_HOST_PATH ${BACKUP_HOST_PATH} < 3 characters"
  /bin/echo "Safety check stopping script"
  exit 1
fi
if [ x$TARGET = x ] ; then
  /bin/echo "TARGET did not get set."
  /bin/echo "Safety check stopping script"
  exit 1
fi

#-------------------------------------------------------------------------
# Wipe out that target (DANGEROUS, BE CAREFUL EDITING THIS)
/usr/bin/ssh ${BACKUP_HOST} /bin/rm -rf --one-file-system --preserve-root ${BACKUP_HOST_PATH}/${TARGET}/

#-------------------------------------------------------------------------
# Take the snapshot

# Determine the newest backup at the remote (for link-dest)
NEWEST=`/usr/bin/ssh ${BACKUP_HOST} /bin/ls -1t ${BACKUP_HOST_PATH} | /usr/bin/head -n 1`
# Make a fresh empty directory for the new backup
/usr/bin/ssh ${BACKUP_HOST} /bin/mkdir ${BACKUP_HOST_PATH}/${TARGET} || exit 1;

# Set the RSYNC_RSH variable to be sure we are using SSH, and set some
# parameters for that
#    -c arcfour:          weak fast encryption
#    -o Compression=no:   rsync already compresses, ssh doesn't need to
#    -x:                  Turn off X tunnelling (shouldn't be on anyways)
export RSYNC_RSH="/usr/bin/ssh -c arcfour -o Compression=no -x"

PERFOPTS=
if [ x$FASTNET = xtrue ] ; then
  # -W tells rsync to skip block-level comparison, and transfer entire files.
  # 
  PERFOPTS=-W
else
  # -z        compress over the transport
  PERFOPTS=-z
fi

# Do the backups with rsync:
for dr in $SOURCE_DIRS; do
  # rsync the source directory into ${TARGET}, using ${NEWEST} as the link
  # destination (that is, if the file is already in ${NEWEST}, hardlink
  # instead of copying anew)
  # -a        archive flags
  # -x        don't cross filesystem boundaries
  # -S                    handle sparse files as sparse files
  # --password-file       password for ssh access
  # --exclude-from        skip these directories
  # --numeric-ids         important if UIDs/GIDs are not in sync
  # --link-dest           If exists here, hardlink instead of creating anew
  #
  # These are not used because we start into a fresh directory:
  # --delete              delete first (may not matter if target empty)
  # --delete-excluded     delete newly excluded directories on taget
  /bin/echo "Taking snapshot of ${dr}  ..."
  /usr/bin/rsync -axS --password-file=${BACKUP_RSYNC_PASSWD_FILE} \
    --exclude-from=${EXCLUDE_FILE} \
    --numeric-ids --link-dest=../${NEWEST} ${PERFOPTS}\
    ${dr} \
    root@${BACKUP_HOST}::${BACKUP_RSYNC_SHARE}/${TARGET}/${dr}/
  # Update modification date on the new directory, after it is filled.
  /usr/bin/ssh ${BACKUP_HOST} /usr/bin/touch ${BACKUP_HOST_PATH}/${TARGET}
done

exit 0
