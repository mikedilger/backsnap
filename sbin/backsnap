#!/bin/sh
# Backsnap:   Pushes or pulls a backup snapshot to/from a directory to backup
VERSION=0.1
#
# Usage:  backsnap <dest> <src> [<src> ...]
#
#     <dest>  - REQUIRED, you must specify a backup destination directory
#     <src>   - REQUIRED, one or more source paths
#
#     Either <dest> or <src> (but not both) may be a remote path in the
#     form <hostname>:<path>.   In these cases, ssh is used.
#
# NOTE ON NEW VERSION 0.1:
# After backsnap 'rotates' previous backups, it will clear the destination.
# Then it will backup each <src> into this destination.  Then it will update
# the count.   If you run a subsequent backsnap command to backup more
# data to this destination IT WILL CLEAR IT FIRST.   So make it all one
# command.  The --nocount and --noclear options have been removed, and
# backsnap will fail to run if it encounters an option it doesn't understand.
#
# Configuration options are in /etc/backsnap/config
#
# backsnap must be run as root, and must have root access via ssh to the
#   remote system, without password prompts (it is recommended to use
#   ssh authorized_keys.  See ssh for details).
#
# Snapshots are rotated daily on a tower-of-hanoi schedule.  To see the
#   backups in date order, use the -t option to ls.
#
# Example usage from cron:
#   59 15 * * *    root   /sbin/backsnap pluto:/ /backups/pluto/
#   59 18 * * *    root   /sbin/backsnap saturn:/ /backups/saturn/
#
# Snapshots are useful nfs mounted read-only, so users can recover their
#   files with a minimum of fuss.
# Sample /etc/exports line:
#   /backups 192.168.1.0/24(ro,async,no_root_squash,no_subtree_check)
# Sample /etc/fstab line:
#   backuphost:/backups/saturn   /snapshots  nfs  proto=tcp,ro,noatime,soft,intr,nolock 0 0
#
# Credits:
#   Written by Mike Dilger
#   Derived from discussions on these pages:
#     http://www.mikerubel.org/computers/rsync_snapshots/
#     http://www.sanitarium.net/golug/rsync_backups.html
#     http://en.wikipedia.org/wiki/Backup_rotation_scheme
#
#-------------------------------------------------------------------------
# Avoid accidental use of $PATH
unset PATH

#-------------------------------------------------------------------------
# Verify we are running as root
THISUID=`/usr/bin/id -u`
if [ $THISUID -ne 0 ] ; then
    /bin/echo "This script will only run as root."
    exit 1
fi

#-------------------------------------------------------------------------

function usage {
    /bin/echo "Usage:  backsnap [options] --dest=<dst> <src> [<src>]"
    /bin/echo "  --version    Print the version"
    /bin/echo "  --fastnet    Don't use network compression"
    /bin/echo "  --dry-run    Just print what it would do, don't actually"
}

#-------------------------------------------------------------------------
# Parse/validate the parameters

INDSTISSET=0
INDST=
INSRCLIST=
for PARAM in $@; do

    case $PARAM in
        -*) true;
            case $PARAM in
                --version)
                    /bin/echo "Version $VERSION"
                    exit 0
                    ;;
                --fastnet)
                    FASTNET=true
                    ;;
                --dry-run)
                    TESTING="/bin/echo"
                    ;;
                -*)
                    /bin/echo "Option $PARAM is not recognized.  Bailing out."
                    usage
                    exit 1
                    ;;
            esac
            ;;
        *)
            if [ $INDSTISSET -eq 1 ] ; then
                INSRCLIST="$INSRCLIST $PARAM"
            else
                INDST=$PARAM
                INDSTISSET=1
            fi
            ;;
    esac
    shift

done

if [ "x$INSRCLIST" = x ] ; then
    /bin/echo "You must specify <dest> and <src>"
    usage
    exit 1
fi
if [ "x$INDST" = x ] ; then
    /bin/echo "You must specify <dest> and <src>"
    usage
fi

# Debug
#/bin/echo "SOURCE      = $INSRCLIST"
#/bin/echo "DESTINATION = $INDST"
#exit 1

# Verify no more than one is remote
REMOTE=0
# note: multiple INSRCLIST is still just 1 line, so this is ok:
REMOTESRC=`/bin/echo $INSRCLIST | /bin/grep : | /usr/bin/wc -l`
REMOTE=`/usr/bin/expr $REMOTE + $REMOTESRC`
REMOTEDST=`/bin/echo $INDST | /bin/grep : | /usr/bin/wc -l`
REMOTE=`/usr/bin/expr $REMOTE + $REMOTEDST`
if [ $REMOTE -gt 1 ] ; then
    echo "At most one of <src> or <dst> may be local"
    exit 1
fi

#-------------------------------------------------------------------------
# Include and validate the config file
source /etc/backsnap/config

if [ z$EXCLUDE_FILE = z ] ; then
    EXCLUDE_FILE=/dev/null
fi
if [ ! -r $EXCLUDE_FILE ] ; then
    /bin/echo "Cannot read exclude file $EXCLUDE_FILE"
    exit 1
fi

#-------------------------------------------------------------------------
# Setup a few general parameters

if [ x$FASTNET = xtrue ] ; then PERFOPTS=-W; else PERFOPTS=-z; fi
if [ $REMOTE -eq 0 ] ; then
    # Not remote, no compressionk
    PERFOPTS=-W;
    export RSYNC_RSH=""
else
    # Set the RSYNC_RSH variable to be sure we are using SSH, and set some
    # parameters for that
    #    -c arcfour:          weak fast encryption
    #    -o Compression=no:   rsync already compresses, ssh doesn't need to
    #    -x:                  Turn off X tunnelling (shouldn't be on anyways)
    # export RSYNC_RSH="/usr/bin/ssh -c arcfour -o Compression=no -x"
    export RSYNC_RSH="/usr/bin/ionice -c3 /usr/bin/ssh -c arcfour -o Compression=no -x"
fi

# Parse INDST
if [ $REMOTEDST -ne 0 ] ; then
    DSTHOST=`/bin/echo ${INDST} | /usr/bin/awk -F: '{print $1}'`
    DSTPATH=`/bin/echo ${INDST} | /usr/bin/awk -F: '{print $2}'`
    DSTACCESS="/usr/bin/ssh ${DSTHOST}"
else
    DSTHOST=
    DSTPATH=${INDST}
    DSTACCESS=
fi

#---------------------------------------------------------------------
# DSTPATH must exist

${DSTACCESS} /usr/bin/test -d ${DSTPATH}
if [ $? -ne 0 ] ; then
  /bin/echo "${INDST} does not exist."
  exit 1
fi

#---------------------------------------------------------------------
# Determine the rotation target

COUNT=`${DSTACCESS} /bin/cat ${DSTPATH}/.count 2>/dev/null`
if [ x$COUNT = x ] ; then COUNT=1; fi

# safety:
COUNTWORDS=`/bin/echo $COUNT | /usr/bin/wc -w`
if [ $COUNTWORDS -ne 1 ] ; then
    /bin/echo ".count at destination does not contain a single number"
    exit 1
fi
# COUNT=`/bin/date +%j`  # <-- daily method has problem if days are skipped

AMOD=`/usr/bin/expr $COUNT % 2`     # Every odd try
BMOD=`/usr/bin/expr $COUNT % 4`     # Every odd 2nd (2, not 4, 6, not 8, ...)
CMOD=`/usr/bin/expr $COUNT % 8`     # Every odd 4th (4, not 8, 12, ...)
DMOD=`/usr/bin/expr $COUNT % 16`    # ...
EMOD=`/usr/bin/expr $COUNT % 32`
FMOD=`/usr/bin/expr $COUNT % 64`
GMOD=`/usr/bin/expr $COUNT % 128`   # Every odd 64th (64, not 128, ...)

# Worst case backup period is (2^(n-2)+1) backups
# Best case backup period is (2^(n-1)) backups
# We go up to H (n=8), so we have backups dating from
#   65 (worst case) to 128 (best case) backups ago

if [ $AMOD -ne 0 ] ; then TARGET='A'
elif [ $BMOD -ne 0 ] ; then TARGET='B'
elif [ $CMOD -ne 0 ] ; then TARGET='C'
elif [ $DMOD -ne 0 ] ; then TARGET='D'
elif [ $EMOD -ne 0 ] ; then TARGET='E'
elif [ $FMOD -ne 0 ] ; then TARGET='F'
elif [ $GMOD -ne 0 ] ; then TARGET='G'
else TARGET='H';
fi

if [ x$TARGET = x ] ; then
    /bin/echo "TARGET did not get set."
    /bin/echo "Safety check stopping script"
    exit 1
fi

#---------------------------------------------------------------------
# Delete target

SAFETYCOUNT=`/bin/echo ${DSTPATH} | /usr/bin/wc -m`
if [ $SAFETYCOUNT -lt 3 ] ; then
    /bin/echo "Destination Path  < 3 characters"
    /bin/echo "Safety check stopping script"
    exit 1
fi

/bin/echo
/bin/echo "Clearing destination ${DSTPATH}/${TARGET} ..."
${TESTING} ${DSTACCESS} /bin/rm -rf --one-file-system --preserve-root ${DSTPATH}/${TARGET}

#---------------------------------------------------------------------
# Determine the newest backup (for link-dest), newest that is not target.

LINKTARG=
NEWESTLIST=`${DSTACCESS} /bin/ls -1t ${DSTPATH}`
for TT in $NEWESTLIST ; do
    if [ x$TT != x$TARGET ] ; then
        LINKTARG="${DSTPATH}/$TT"
        break;
    fi
done

#-------------------------------------------------------------------------
# Loop for each src specified
for INSRC in $INSRCLIST; do

    /bin/echo

    # Parse INSRC
    if [ $REMOTESRC -ne 0 ] ; then
        SRCPATH=`/bin/echo ${INSRC} | /usr/bin/awk -F: '{print $2}'`
    else
        SRCPATH=${INSRC}
    fi
    SRCDIR=`/usr/bin/dirname $SRCPATH`

    #---------------------------------------------------------------------
    # If dest directory exists, clear it
    /bin/echo "Clearing destination ${DSTPATH}/${TARGET}${SRCPATH} ..."
    ${TESTING} ${DSTACCESS} /bin/rm -rf --one-file-system --preserve-root ${DSTPATH}/${TARGET}${SRCPATH}
    
    #---------------------------------------------------------------------
    # Make a directory for the new backup
    /bin/echo "Making destination ${DSTPATH}/${TARGET}${SRCDIR} ..."
    ${TESTING} ${DSTACCESS} /bin/mkdir -p ${DSTPATH}/${TARGET}${SRCDIR} || exit 2;

    #---------------------------------------------------------------------
    # Take the snapshot

    # rsync the source directory into ${TARGET}, using ${NEWEST} as the link
    # destination (that is, if the file is already in ${NEWEST}, hardlink
    # instead of copying anew)
    # -a        archive flags
    # -x        don't cross filesystem boundaries
    # -S                    handle sparse files as sparse files
    # --password-file       password for ssh access
    # --exclude-from        skip these directories
    # --numeric-ids         important if UIDs/GIDs are not in sync
    # --link-dest           If exists here, hardlink instead of creating anew
    #
    # These are not used because we start into a fresh directory:
    # --delete              delete first (may not matter if target empty)
    # --delete-excluded     delete newly excluded directories on taget
    #

    /bin/echo "Taking snapshot of ${INSRC}  ..."

    if [ x$LINKTARG != x ] ; then
        LINKPARAM=--link-dest=${LINKTARG}${SRCPATH}
    else
        LINKPARAM=
    fi

    /usr/bin/ionice -c3 ${TESTING} /usr/bin/rsync -axS \
        --exclude-from=${EXCLUDE_FILE} \
        --numeric-ids ${LINKPARAM} ${PERFOPTS} \
        ${INSRC} ${INDST}/${TARGET}${SRCDIR}
    exitval=$?
    # Errors which are acceptible for proceeding: 0,6,21,23,24,25
    case $exitval in
        (0|6|21|23|24|25) ;;
        *)
            /bin/echo "Bailing out."
            exit 1
            ;;
    esac

done

# Mark target as new, after we are finished with it
${TESTING} ${DSTACCESS} /usr/bin/touch ${DSTPATH}/${TARGET}

# ------------------------------------------------------------------
# Update the count only after we are done (if it was only partial, the
# count will be the same, so the next backup will just try again in the
# same slot)

COUNT=`/usr/bin/expr $COUNT + 1`
if [ $REMOTEDST -ne 0 ] ; then
    ${TESTING} ${DSTACCESS} "/bin/echo $COUNT > ${DSTPATH}/.count"
else 
    if [ x$TESTING = x ] ; then
        /bin/echo $COUNT > ${DSTPATH}/.count
    fi
fi

exit 0
