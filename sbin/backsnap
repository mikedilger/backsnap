#!/bin/sh -x
# Backsnap
#
# Derived from discussions on this page:
#   http://www.mikerubel.org/computers/rsync_snapshots/
#
# Configure /etc/backsnap/config
# Then run /sbin/backsnap regularly
#
# Example usage from cron:
#   0 */4 * * *    root   /sbin/backsnap
#
#-------------------------------------------------------------------------
# Avoid accidental use of $PATH
unset PATH

# Define commands
ID=/usr/bin/id;
ECHO=/bin/echo;
MOUNT=/bin/mount;
RM=/bin/rm;
MV=/bin/mv;
CP=/bin/cp;
TOUCH=/bin/touch;
RSYNC=/usr/bin/rsync;
MKDIR=/bin/mkdir;

#-------------------------------------------------------------------------
# Verify we are running as root
THISUID=`$ID -u`
if [ $THISUID -ne 0 ] ; then
  echo "This script will only run as root."
  exit 1
fi

#-------------------------------------------------------------------------
# Include config file
source /etc/backsnap/config

# validate variables defined in config
if [ z$BACKUP_HOST = z ] ; then
  echo "BACKUP_HOST not defined"
  exit 1
fi
if [ x$BACKUP_HOST_PATH = z ] ; then
  echo "BACKUP_HOST_PATH not defined"
  exit 1
fi
if [ 'z$SOURCE_DIRS' = 'z' ] ; then
  echo "SOURCE_DIRS not defined"
  exit 1
fi
for dr in $SOURCE_DIRS; do
  if [ ! -d $dr ] ; then
    echo "Source directory $dr not found"
    exit 1
  fi
done
if [ z$BACKUP_RSYNC_PASSWD_FILE = z ] ; then
  echo "BACKUP_RSYNC_PASSWD_FILE is not set"
  exit 1
fi
if [ ! -f $BACKUP_RSYNC_PASSWD_FILE ] ; then
  echo "$BACKUP_RSYNC_PASSWD_FILE doesn't exist"
  exit 1
fi
if [ ! -r $BACKUP_RSYNC_PASSWD_FILE ] ; then
  echo "$BACKUP_RSYNC_PASSWD_FILE cannot be read"
  exit 1
fi
if [ x$BACKUP_RSYNC_SHARE = x ] ; then
  echo "BACKUP_RSYNC_SHARE is not set"
  exit 1
fi

#-------------------------------------------------------------------------
# Determine the rotation factor


DOY=`date +%j`
AMOD=`expr $DOY % 2`     # Every odd 1-day
BMOD=`expr $DOY % 4`     # Every odd 2-day  (2, not 4, 6, not 8, ...)
CMOD=`expr $DOY % 8`     # Every odd 4-day  (4, not 8, 12, not 16, ...)
DMOD=`expr $DOY % 16`    # ...
EMOD=`expr $DOY % 32`
FMOD=`expr $DOY % 64`
GMOD=`expr $DOY % 128`   # Every odd 64-day (64, not 128, ...)

# Worst case backup period is (2^(n-2)+1) days
# Best case backup period is (2^(n-1)) days
# We go up to H (n=8), so we have backups dating from
#   65 (worst case) to 128 (best case) days ago

if [ $AMOD -ne 0 ] ; then TARGET='A'
elif [ $BMOD -ne 0 ] ; then TARGET='B'
elif [ $CMOD -ne 0 ] ; then TARGET='C'
elif [ $DMOD -ne 0 ] ; then TARGET='D'
elif [ $EMOD -ne 0 ] ; then TARGET='E'
elif [ $FMOD -ne 0 ] ; then TARGET='F'
elif [ $GMOD -ne 0 ] ; then TARGET='G'
else TARGET='H';
fi

# SAFETY CHECK, BACKUP_HOST_PATH must be at least 3 characters long
BHPC=`echo ${BACKUP_HOST_PATH} | wc -m`
if [ $BHPC -lt 3 ] ; then
  echo "BACKUP_HOST_PATH ${BACKUP_HOST_PATH} < 3 characters"
  echo "Safety check stopping script"
  exit 1
fi
if [ x$TARGET = x ] ; then
  echo "TARGET did not get set."
  echo "Safety check stopping script"
  exit 1
fi

# Wipe out that target (DANGEROUS, BE CAREFUL EDITING THIS)
/usr/bin/ssh ${BACKUP_HOST} /bin/rm -rf --one-file-system --preserve-root ${BACKUP_HOST_PATH}/${TARGET}/

# Determine the newest backup at the remote (for link-dest)
NEWEST=`/usr/bin/ssh ${BACKUP_HOST} /bin/ls -1t ${BACKUP_HOST_PATH} | head -n 1`
# Make a fresh empty directory for the new backup
/usr/bin/ssh ${BACKUP_HOST} mkdir ${BACKUP_HOST_PATH}/${TARGET} || exit 1;

# Do the backups with rsync:
for dr in $SOURCE_DIRS; do
  # rsync the source directory into ${TARGET}, using ${NEWEST} as the link
  # destination (that is, if the file is already in ${NEWEST}, hardlink
  # instead of copying anew)
  # -a        archive flags
  # -v        verbose (not really needed if run from cron)
  # -x        don't cross filesystem boundaries
  # --delete  delete first (maybe not even necessary since 0/ is empty)
  echo "Taking snapshot of ${dr}..."
  $RSYNC -avx --password-file=${BACKUP_RSYNC_PASSWD_FILE} --delete \
    --link-dest=../${NEWEST} ${dr} \
    ${BACKUP_HOST}::${BACKUP_RSYNC_SHARE}/${TARGET}/${dr}/
done

exit 0
