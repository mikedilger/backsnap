#!/bin/sh
# Backsnap:   Pushes or pulls a backup snapshot to/from a directory to backup
#
# Parameters:  # backsnap <source> <destination>
#
#   backsnap <directory1> <directory2>
#          This backups up directory1 to directory2 on the same system
#   backsnap <directory1> <host>:<directory2>
#          This backs up directory1 to remote host:directory2 (push) via ssh
#   backsnap <host>:<directory1> <directory2>
#          This backs up remote host:directory1 to directory2 (pull) via ssh
#
# Configuration options are in /etc/backsnap/config
#
# backsnap must be run as root, and must have root access via ssh to the
#   remote system, without password prompts (it is recommended to use
#   ssh authorized_keys.  See ssh for details).
#
# Snapshots are rotated daily on a tower-of-hanoi schedule.  To see the
#   backups in date order, use the -t option to ls.
# This is designed to be run once daily.  If you run it more than once daily,
#   The subsequent runs will simply replace the previous run that day.
#
# Example usage from cron:
#   59 15 * * *    root   /sbin/backsnap pluto:/ /backups/pluto/
#   59 18 * * *    root   /sbin/backsnap saturn:/ /backups/saturn/
#
# Snapshots are useful nfs mounted read-only, so users can recover their
#   files with a minimum of fuss.
# Sample /etc/exports line:
#   /backups 192.168.1.0/24(ro,async,no_root_squash,no_subtree_check)
# Sample /etc/fstab line:
#   backuphost:/backups/saturn   /snapshots  nfs  proto=tcp,ro,noatime,soft,intr,nolock 0 0
#
# Credits:
#   Written by Mike Dilger
#   Derived from discussions on these pages:
#     http://www.mikerubel.org/computers/rsync_snapshots/
#     http://www.sanitarium.net/golug/rsync_backups.html
#     http://en.wikipedia.org/wiki/Backup_rotation_scheme
#
#-------------------------------------------------------------------------
# Avoid accidental use of $PATH
unset PATH

# Define TESTING as /bin/echo to see what the script would do, without
# actually doing it
# TESTING="/bin/echo"

#-------------------------------------------------------------------------
# Verify we are running as root
THISUID=`/usr/bin/id -u`
if [ $THISUID -ne 0 ] ; then
  /bin/echo "This script will only run as root."
  exit 1
fi

#-------------------------------------------------------------------------
# Validate the parameters

if [ $# -ne 2 ] ; then
  /bin/echo "This script requires exactly 2 parameters, <src> <dst>"
  exit 1
fi

SRC=$1
if [ x$SRC = x ] ; then
  /bin/echo "You must specify two parameters, <src> <dst>"
  exit 1
fi
DST=$2
if [ x$DST = x ] ; then
  /bin/echo "You must specify two parameters, <src> <dst>"
fi

# Verify exactly one is remote
REMOTE=0
REMOTESRC=`/bin/echo $SRC | /bin/grep : | /usr/bin/wc -l`
REMOTE=`/usr/bin/expr $REMOTE + $REMOTESRC`
REMOTEDST=`/bin/echo $DST | /bin/grep : | /usr/bin/wc -l`
REMOTE=`/usr/bin/expr $REMOTE + $REMOTEDST`
if [ $REMOTE -ne 1 ] ; then
  echo "Exactly one of <src> or <dst> must be local"
  exit 1
fi

if [ $REMOTESRC -ne 0 ] ; then
  SRCHOST=`/bin/echo $SRC | /usr/bin/awk -F: '{print $1}'`
  SRCPATH=`/bin/echo $SRC | /usr/bin/awk -F: '{print $2}'`
fi
if [ $REMOTEDST -ne 0 ] ; then
  DSTHOST=`/bin/echo $DST | /usr/bin/awk -F: '{print $1}'`
  DSTPATH=`/bin/echo $DST | /usr/bin/awk -F: '{print $2}'`
fi

#-------------------------------------------------------------------------
# Include and validate the config file
source /etc/backsnap/config

if [ z$EXCLUDE_FILE = z ] ; then
    EXCLUDE_FILE=/dev/null
fi
if [ ! -r $EXCLUDE_FILE ] ; then
  /bin/echo "Cannot read exclude file $EXCLUDE_FILE"
  exit 1
fi

PERFOPTS=
if [ x$FASTNET = xtrue ] ; then
  # -W tells rsync to skip block-level comparison, and transfer entire files.
  # 
  PERFOPTS=-W
else
  # -z        compress over the transport
  PERFOPTS=-z
fi

#-------------------------------------------------------------------------
# Determine the rotation target

# Read the count
if [ $REMOTEDST -ne 0 ] ; then
  COUNT=`/usr/bin/ssh ${DSTHOST} /bin/cat ${DSTPATH}/.count 2>/dev/null`
else 
  COUNT=`/bin/cat ${DST}/.count 2>/dev/null`
fi
if [ x$COUNT = x ] ; then
  COUNT=1
fi
# safety:
COUNTWORDS=`/bin/echo $COUNT | /usr/bin/wc -w`
if [ $COUNTWORDS -ne 1 ] ; then
  /bin/echo ".count at destination does not contain a single number"
  exit 1
fi
# COUNT=`/bin/date +%j`  # <-- daily method has problem if days are skipped

AMOD=`/usr/bin/expr $COUNT % 2`     # Every odd try
BMOD=`/usr/bin/expr $COUNT % 4`     # Every odd 2nd (2, not 4, 6, not 8, ...)
CMOD=`/usr/bin/expr $COUNT % 8`     # Every odd 4th (4, not 8, 12, ...)
DMOD=`/usr/bin/expr $COUNT % 16`    # ...
EMOD=`/usr/bin/expr $COUNT % 32`
FMOD=`/usr/bin/expr $COUNT % 64`
GMOD=`/usr/bin/expr $COUNT % 128`   # Every odd 64th (64, not 128, ...)

# Worst case backup period is (2^(n-2)+1) backups
# Best case backup period is (2^(n-1)) backups
# We go up to H (n=8), so we have backups dating from
#   65 (worst case) to 128 (best case) backups ago

if [ $AMOD -ne 0 ] ; then TARGET='A'
elif [ $BMOD -ne 0 ] ; then TARGET='B'
elif [ $CMOD -ne 0 ] ; then TARGET='C'
elif [ $DMOD -ne 0 ] ; then TARGET='D'
elif [ $EMOD -ne 0 ] ; then TARGET='E'
elif [ $FMOD -ne 0 ] ; then TARGET='F'
elif [ $GMOD -ne 0 ] ; then TARGET='G'
else TARGET='H';
fi

if [ x$TARGET = x ] ; then
  /bin/echo "TARGET did not get set."
  /bin/echo "Safety check stopping script"
  exit 1
fi

# Update the count
COUNT=`/usr/bin/expr $COUNT + 1`
if [ $REMOTEDST -ne 0 ] ; then
  ${TESTING} /usr/bin/ssh ${DSTHOST} "/bin/echo $COUNT > ${DSTPATH}/.count"
else 
  if [ x$TESTING = x ] ; then
    /bin/echo $COUNT > ${DST}/.count
  fi
fi

#-------------------------------------------------------------------------
# Delete the target

if [ $REMOTEDST -ne 0 ] ; then
  
  # SAFETY CHECK, must be at least 3 characters long
  SAFETYCOUNT=`/bin/echo ${DSTPATH} | /usr/bin/wc -m`
  if [ $SAFETYCOUNT -lt 3 ] ; then
    /bin/echo "Destination Path  < 3 characters"
    /bin/echo "Safety check stopping script"
    exit 1
  fi

  /bin/echo "Clearing destination ${DSTPATH}/${TARGET}/ ..."
  # Wipe out that target (DANGEROUS, BE CAREFUL EDITING THIS)
  ${TESTING} /usr/bin/ssh ${DSTHOST} /bin/rm -rf --one-file-system --preserve-root ${DSTPATH}/${TARGET}/

else

  # SAFETY CHECK, must be at least 3 characters long
  SAFETYCOUNT=`/bin/echo ${DST} | /usr/bin/wc -m`
  if [ $SAFETYCOUNT -lt 3 ] ; then
    /bin/echo "Destination Path  < 3 characters"
    /bin/echo "Safety check stopping script"
    exit 1
  fi

  /bin/echo "Clearing destination ${DST}/${TARGET}/ ..."
  # Wipe out that target (DANGEROUS, BE CAREFUL EDITING THIS)
  ${TESTING} /bin/rm -rf --one-file-system --preserve-root ${DST}/${TARGET}/

fi

#-------------------------------------------------------------------------
# Determine the newest backup (for link-dest), newest that is not target.

LINKPARAM=
if [ $REMOTEDST -ne 0 ] ; then
  NEWESTLIST=`/usr/bin/ssh ${DSTHOST} /bin/ls -1t ${DSTPATH}`
else
  NEWESTLIST=`/bin/ls -1t ${DST}`
fi
for TT in $NEWESTLIST ; do
  if [ x$TT != x$TARGET ] ; then
    LINKPARAM="--link-dest=../$TT"
    break;
  fi
done

#-------------------------------------------------------------------------
# Make a fresh empty directory for the new backup

if [ $REMOTEDST -ne 0 ] ; then
  /bin/echo "Making empty destination ${DSTPATH}/${TARGET} ..."
  ${TESTING} /usr/bin/ssh ${DSTHOST} /bin/mkdir ${DSTPATH}/${TARGET} || exit 2;
else
  /bin/echo "Making empty destination ${DST}/${TARGET} ..."
  ${TESTING} /bin/mkdir ${DST}/${TARGET} || exit 2;
fi

#-------------------------------------------------------------------------
# Take the snapshot

  # rsync the source directory into ${TARGET}, using ${NEWEST} as the link
  # destination (that is, if the file is already in ${NEWEST}, hardlink
  # instead of copying anew)
  # -a        archive flags
  # -x        don't cross filesystem boundaries
  # -S                    handle sparse files as sparse files
  # --password-file       password for ssh access
  # --exclude-from        skip these directories
  # --numeric-ids         important if UIDs/GIDs are not in sync
  # --link-dest           If exists here, hardlink instead of creating anew
  #
  # These are not used because we start into a fresh directory:
  # --delete              delete first (may not matter if target empty)
  # --delete-excluded     delete newly excluded directories on taget
  #
  # Set the RSYNC_RSH variable to be sure we are using SSH, and set some
  # parameters for that
  #    -c arcfour:          weak fast encryption
  #    -o Compression=no:   rsync already compresses, ssh doesn't need to
  #    -x:                  Turn off X tunnelling (shouldn't be on anyways)
  # export RSYNC_RSH="/usr/bin/ssh -c arcfour -o Compression=no -x"

/bin/echo "Taking snapshot of ${SRC}  ..."

if [ $REMOTEDST -ne 0 ] ; then

  ${TESTING} /usr/bin/rsync -axS \
    -e "/usr/bin/ssh -c arcfour -o Compression=no -x" \
    --exclude-from=${EXCLUDE_FILE} \
    --numeric-ids ${LINKPARAM} ${PERFOPTS} \
    ${SRC}  root@${DSTHOST}:${DSTPATH}/${TARGET}/${SRC}
  # Update modification date on the new directory, after it is filled.
  ${TESTING} /usr/bin/ssh ${DSTHOST} /usr/bin/touch ${DSTPATH}/${TARGET}

else

  ${TESTING} /usr/bin/rsync -axS \
    -e "/usr/bin/ssh -c arcfour -o Compression=no -x" \
    --exclude-from=${EXCLUDE_FILE} \
    --numeric-ids ${LINKPARAM} ${PERFOPTS} \
    root@${SRCHOST}:${SRCPATH}  ${DST}/${TARGET}/${SRCPATH}
  ${TESTING} /usr/bin/touch ${DST}/${TARGET}

fi

exit 0
