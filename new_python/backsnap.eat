#!/bin/sh

#-------------------------------------------------------------------------
# Parse/validate the parameters

INDSTISSET=0
INDST=
INSRCLIST=
for PARAM in $@; do

    case $PARAM in
        -*) true;
            case $PARAM in
                --version)
                    /bin/echo "Version $VERSION"
                    exit 0
                    ;;
                --fastnet)
                    FASTNET=true
                    ;;
                --maxbackups)
                    shift
                    MAXBACKUPS=$1
                    ;;
                --dry-run)
                    TESTING="/bin/echo"
                    ;;
                -*)
                    /bin/echo "Option $PARAM is not recognized.  Bailing out."
                    usage
                    exit 1
                    ;;
            esac
            ;;
        *)
            if [ $INDSTISSET -eq 1 ] ; then
                INSRCLIST="$INSRCLIST $PARAM"
            else
                INDST=$PARAM
                INDSTISSET=1
            fi
            ;;
    esac
    shift

done

if [ "x$INSRCLIST" = x ] ; then
    /bin/echo "You must specify <dest> and <src>"
    usage
    exit 1
fi
if [ "x$INDST" = x ] ; then
    /bin/echo "You must specify <dest> and <src>"
    usage
fi

# Debug
#/bin/echo "SOURCE      = $INSRCLIST"
#/bin/echo "DESTINATION = $INDST"
#exit 1

# Verify no more than one is remote
REMOTE=0
# note: multiple INSRCLIST is still just 1 line, so this is ok:
REMOTESRC=`/bin/echo $INSRCLIST | /bin/grep : | /usr/bin/wc -l`
REMOTE=`/usr/bin/expr $REMOTE + $REMOTESRC`
REMOTEDST=`/bin/echo $INDST | /bin/grep : | /usr/bin/wc -l`
REMOTE=`/usr/bin/expr $REMOTE + $REMOTEDST`
if [ $REMOTE -gt 1 ] ; then
    echo "At most one of <src> or <dst> may be local"
    exit 1
fi

# Parse INDST
if [ $REMOTEDST -ne 0 ] ; then
    DSTHOST=`/bin/echo ${INDST} | /usr/bin/awk -F: '{print $1}'`
    DSTPATH=`/bin/echo ${INDST} | /usr/bin/awk -F: '{print $2}'`
    DSTACCESS="/usr/bin/ssh ${DSTHOST}"
else
    DSTHOST=
    DSTPATH=${INDST}
    DSTACCESS=
fi

#-------------------------------------------------------------------------
# Deal with possibly remote config and excludes files

TMPDIR=`/usr/bin/mktemp -d`
add_on_exit /bin/rm -rf --one-file-system --preserve-root $TMPDIR

if [ $REMOTEDST -ne 0 ] ; then
    /usr/bin/ionice -c 3 /usr/bin/scp $DSTHOST:$DSTPATH/.backsnap/config $DSTHOST:$DSTPATH/.backsnap/excludes $TMPDIR
    if [ $? -ne 0 ] ; then
        /bin/echo "Failed to find $DSTHOST:$DSTPATH/.backsnap/config or $DSTHOST:$DSTPATH/.backsnap/excludes"
        exit 1
    fi
else
    /bin/cp $DSTPATH/.backsnap/config $DSTPATH/.backsnap/excludes $TMPDIR
    if [ $? -ne 0 ] ; then
        /bin/echo "Failed to find $DSTPATH/.backsnap/config or $DSTPATH/.backsnap/excludes"
        exit 1
    fi
fi
source $TMPDIR/config
EXCLUDE_FILE=$TMPDIR/excludes

#-------------------------------------------------------------------------
# Setup a few general parameters

if [ x$FASTNET = xtrue ] ; then PERFOPTS=-W; else PERFOPTS=-z; fi
if [ $REMOTE -eq 0 ] ; then
    # Not remote, no compressionk
    PERFOPTS=-W;
    export RSYNC_RSH=""
else
    # Set the RSYNC_RSH variable to be sure we are using SSH, and set some
    # parameters for that
    #    -c arcfour:          weak fast encryption
    #    -o Compression=no:   rsync already compresses, ssh doesn't need to
    #    -x:                  Turn off X tunnelling (shouldn't be on anyways)
    # export RSYNC_RSH="/usr/bin/ssh -c arcfour -o Compression=no -x"
    export RSYNC_RSH="/usr/bin/ionice -c 3 /usr/bin/ssh -c arcfour -o Compression=no -x"
fi

#---------------------------------------------------------------------
# DSTPATH must exist

${DSTACCESS} /usr/bin/test -d ${DSTPATH}
if [ $? -ne 0 ] ; then
  /bin/echo "${INDST} does not exist."
  exit 1
fi

#---------------------------------------------------------------------
# Determine the rotation target

if [ z"$MAXBACKUPS" = z ] ; then MAXBACKUPS=8; fi

COUNT=`${DSTACCESS} /bin/cat ${DSTPATH}/.backsnap/count 2>/dev/null`
if [ x$COUNT = x ] ; then COUNT=0; fi

# safety:
COUNTWORDS=`/bin/echo $COUNT | /usr/bin/wc -w`
if [ $COUNTWORDS -ne 1 ] ; then
    /bin/echo "count at destination does not contain a single number"
    exit 1
fi
# COUNT=`/bin/date +%j`  # <-- daily method has problem if days are skipped

if [ $COUNT -eq 0 ] ; then
  # Pre-tower strategy, do last level once
  TARGET='LEVEL'$MAXBACKUPS
else
  # Tower of hanoi strategy
  MODULUS=1
  for (( LVL=1 ; $LVL < $MAXBACKUPS ; LVL=$LVL+1 )) ; do
    MODULUS=`/usr/bin/expr $MODULUS \* 2`
    MOD=`/usr/bin/expr $COUNT % $MODULUS`
    if [ $MOD -ne 0 ] ; then break; fi
  done
  # Worst case backup period is (2^(n-2)+1) backups
  # Best case backup period is (2^(n-1)) backups
  TARGET='LEVEL'$LVL
fi

if [ x$TARGET = x ] ; then
    /bin/echo "TARGET did not get set."
    /bin/echo "Safety check stopping script"
    exit 1
fi

#---------------------------------------------------------------------
# Validate access for first SRC (before deleting target)

# If multiple src, just use the first for validation:
INSRC=`echo $INSRCLIST | /usr/bin/awk '{ print $1; }'`

if [ $REMOTESRC -ne 0 ] ; then
    SRCPATH=`/bin/echo ${INSRC} | /usr/bin/awk -F: '{print $2}'`
else
    SRCPATH=${INSRC}
fi
SRCDIR=`/usr/bin/dirname $SRCPATH`

# NOTE: we use ${INDST}/${TARGET} instead of ${INDST}/${TARGET}/${SRCDIR}
# because we know it exists, no need to create it, tests our permissions,
# and --dry-run doesn't write anything anyways.

# not recursive, dirs copys as dir not going in,
# --links, --perms --times --group --owner --devices --specials all from -a

${TESTING} /usr/bin/ionice -c 3 /usr/bin/rsync \
    --links --perms --times --group --owner \
    --devices --specials --one-file-system --sparse \
    --numeric-ids ${PERFOPTS} --dirs \
    --dry-run \
    ${INSRC} ${INDST}/${TARGET}
exitval=$?
# Errors which are acceptible for proceeding: 0,6,21,23,24,25
case $exitval in
    (0|6|21|23|24|25) ;;
    *)
        /bin/echo "Dry-run failed.  Bailing out."
        exit 1
        ;;
esac

# Unset these validation variables
SRCPATH=
SRCDIR=

#---------------------------------------------------------------------
# Delete target

SAFETYCOUNT=`/bin/echo ${DSTPATH} | /usr/bin/wc -m`
if [ $SAFETYCOUNT -lt 3 ] ; then
    /bin/echo "Destination Path  < 3 characters"
    /bin/echo "Safety check stopping script"
    exit 1
fi

/bin/echo
/bin/echo "Clearing destination ${DSTPATH}/${TARGET} ..."
${TESTING} ${DSTACCESS} /usr/bin/ionice -c 3 /bin/rm -rf --one-file-system --preserve-root ${DSTPATH}/${TARGET}

#---------------------------------------------------------------------
# Determine the newest backup (for link-dest), newest that is not target.

LINKTARG=
NEWESTLIST=`${DSTACCESS} /bin/ls -1t ${DSTPATH}`
for TT in $NEWESTLIST ; do
    if [ x$TT != x$TARGET ] ; then
        LINKTARG="${DSTPATH}/$TT"
        break;
    fi
done

#-------------------------------------------------------------------------
# Loop for each src specified
for INSRC in $INSRCLIST; do

    /bin/echo

    # Parse INSRC
    if [ $REMOTESRC -ne 0 ] ; then
        SRCPATH=`/bin/echo ${INSRC} | /usr/bin/awk -F: '{print $2}'`
    else
        SRCPATH=${INSRC}
    fi
    SRCDIR=`/usr/bin/dirname $SRCPATH`

    #---------------------------------------------------------------------
    # If dest directory exists, clear it
    /bin/echo "Clearing destination ${DSTPATH}/${TARGET}${SRCPATH} ..."
    ${TESTING} ${DSTACCESS} /usr/bin/ionice -c 3 /bin/rm -rf --one-file-system --preserve-root ${DSTPATH}/${TARGET}${SRCPATH}

    #---------------------------------------------------------------------
    # Make a directory for the new backup
    /bin/echo "Making destination ${DSTPATH}/${TARGET}${SRCDIR} ..."
    ${TESTING} ${DSTACCESS} /bin/mkdir -p ${DSTPATH}/${TARGET}${SRCDIR} || exit 2;

    #---------------------------------------------------------------------
    # Take the snapshot

    # rsync the source directory into ${TARGET}, using ${NEWEST} as the link
    # destination (that is, if the file is already in ${NEWEST}, hardlink
    # instead of copying anew)
    # -a        archive flags
    # -x        don't cross filesystem boundaries
    # -S                    handle sparse files as sparse files
    # --password-file       password for ssh access
    # --exclude-from        skip these directories
    # --numeric-ids         important if UIDs/GIDs are not in sync
    # --link-dest           If exists here, hardlink instead of creating anew
    #
    # These are not used because we start into a fresh directory:
    # --delete              delete first (may not matter if target empty)
    # --delete-excluded     delete newly excluded directories on taget
    #

    /bin/echo "Taking snapshot of ${INSRC}  ..."

    if [ x$LINKTARG != x ] ; then
        LINKPARAM=--link-dest=${LINKTARG}${SRCPATH}
    else
        LINKPARAM=
    fi

    ${TESTING} /usr/bin/ionice -c 3 /usr/bin/rsync --archive \
        --one-file-system --sparse \
        --exclude-from=${EXCLUDE_FILE} \
        --numeric-ids ${LINKPARAM} ${PERFOPTS} \
        ${INSRC} ${INDST}/${TARGET}${SRCDIR}
    exitval=$?
    # Errors which are acceptible for proceeding: 0,6,21,23,24,25
    case $exitval in
        (0|6|21|23|24|25) ;;
        *)
            /bin/echo "Bailing out."
            exit 1
            ;;
    esac

done

# Mark target as new, after we are finished with it
${TESTING} ${DSTACCESS} /usr/bin/touch ${DSTPATH}/${TARGET}

# ------------------------------------------------------------------
# Update the count only after we are done (if it was only partial, the
# count will be the same, so the next backup will just try again in the
# same slot)

COUNT=`/usr/bin/expr $COUNT + 1`
if [ $REMOTEDST -ne 0 ] ; then
    ${TESTING} ${DSTACCESS} "/bin/echo $COUNT > ${DSTPATH}/.backsnap/count"
else
    if [ x$TESTING = x ] ; then
        /bin/echo $COUNT > ${DSTPATH}/.backsnap/count
    fi
fi

exit 0
