#!/bin/env python3
# -*- mode: python; -*-

# DEFINE VARIABLES -----------------------------------------------------------
MANUAL="""
You must first configure the backup destination, in particular the excludes
file.   At the destination, there must exist a .backsnap directory and an
excludes file:

  <dest>/.backsnap/excludes  - list of directories and files to exclude,
                               one path per line.

Backsnap will create and manage other files in this directory you can
safely ignore (e.g. count, filelist).

Backups at the destination will be in directories named LEVELn/
where n is the level.  These level numbers do NOT represent time order,
but rather tower-of-hanoi depth.  To list the backups from oldest to
newest, pass the -t option to /bin/ls.

Do not run backsnap multiple times to back up multiple sources.  Rather
list all the sources to be backed up on the command line for one
invocation.  Otherwise it will increment the count, clear the destination
(possibly erasing an older backup), and backup the data at a different
backup level from the previous invocation.

Backsnap must be run as root, and it must have root access to <dest>
and <src>.  If this includes root access over the network via ssh,
then ssh must not be impinged with password prompts. This can be
achieved with ssh authorized_keys.  See ssh for details.

Features:

* Keeps multiple levels of backups using the tower-of-hanoi strategy.
* Uses rsync and the previous backup in such a way that it only copies
  data that has changed since the previous backup was taken.
* If a file hasn't changed, it is included in the new backup via a hardlink,
  so the data is not duplicated and yet the new backup directory contains
  all of the files (for this reason, keeping 8 levels of backup doesn't take
  8x of the original space, in practice it is closer to 2x)
* Supports both push and pull architectures
* Is portage-aware, optionally skipping system files which have not been
  altered from the package default
* Backups are fully functional filesystems, so they are mountable (read-only
  please) and recovery is a cinch.  (If we compressed them we wouldn't save
  space because we'd lose the hardlink savings)
* Encrypted transit using ssh
* Uses nice and ionice so your system doesn't bog down during operation
* Optionally uses network compression for slow (or expensive) networks

Examples:

  Example push usage from cron:
    59 15 * * *  root  /sbin/backsnap pluto:/backups/earth / /var

  Example pull usage from cron:
    45 2 * * 2   root  /sbin/backsnap /backups/earth earth:/ earth:/boot earth:/var

  Example read-only nfs mounting backups, backup server /etc/exports:
    /backups 192.168.1.0/24(ro,async,no_root_squash,no_subtree_check)

  Example read-only nfs mounting backups, client fstab:
    pluto:/backups/earth   /snapshots  nfs  proto=tcp,ro,noatime,soft,intr,nolock 0 0
"""

CREDITS="""by Michael Dilger <mike@mikedilger.com>
  nongentoo checking code originally from:
    Vincent Delft <vincent_delft@yahoo.com>
  rsync backup ideas taken from:
    http://www.mikerubel.org/computers/rsync_snapshots/
    http://www.sanitarium.net/golug/rsync_backups.html
  tower of hanoi strategy from:
    http://en.wikipedia.org/wiki/Backup_rotation_scheme
"""

AUTHOR="Michael Dilger"
VERSION="0.4"
LAST_MODIFICATION="18 February 2011"

# IMPORTS --------------------------------------------------------------------

import os.path,os
try:
  import cPickle as pickle
except:
  import pickle
import sys
import string
import fnmatch
import signal

# EXIT HANDLER AND TRAP SIGNALS ----------------------------------------------

ONEXIT=[]
def myexitcode(*args):
  global ONEXIT
  for code in ONEXIT:
    exec(code)
  sys.exit(1)

signal.signal(signal.SIGSEGV,myexitcode)
signal.signal(signal.SIGINT,myexitcode)
signal.signal(signal.SIGABRT,myexitcode)
signal.signal(signal.SIGHUP,myexitcode)
signal.signal(signal.SIGQUIT,myexitcode)
signal.signal(signal.SIGTERM,myexitcode)

# e.g.
  #ONEXIT.append('''# remove temp dir
  ##/bin/rm -rf --one-file-system --preserve-root $TMPDIR   # but this is bash
  #'''
  #);

# PARSE COMMAND LINE ---------------------------------------------------------

def print_manual(option,opt,value,parser):
  global MANUAL
  parser.print_help()
  print(MANUAL)
  myexitcode()

def print_credits(option,opt,value,parser):
  global CREDITS
  print(CREDITS)
  myexitcode()

from optparse import OptionParser
parser = OptionParser(usage="usage: %prog [options] <dest> <src> [<src> ...]",
                      version="%prog {0}".format(VERSION),
                      description="Backsnap (backup snapshot) backs up "
                      "directories, manages multiple backup levels, works "
                      "over the network, and optionally skips system files.  "
                      "You must specify a <dest> path and "
                      "at least one <src> path.  "
                      "Either <dest> or <src> (but not both) may be a remote "
                      "path in the form <hostname>:<path>, in which case ssh "
                      "is used.   If <src> is in this form, all <src> "
                      "arguments must use the same hostname.")

parser.add_option("--manual",
                  action="callback", callback=print_manual,
                  help="Long help message (like a man page)")
parser.add_option("--dry-run",
                  action="store_true",
                  dest="dryrun",
                  default=False,
                  help="Just print what it would do, but don't actually do it")
parser.add_option("--slownet",
                  action="store_true",
                  dest="slownet",
                  default=False,
                  help="Use network compression [default: %default]")
parser.add_option("--rootdir",
                  action="store",
                  dest="rootdir",
                  default="/",
                  help="Root directory of the source [default: %default]")
parser.add_option("--mtimeonly",
                  action="store_true",
                  dest="mtimeonly",
                  default=False,
                  help="Compare system files based on mtime only (skip md5) "
                  "[default: %default]")
parser.add_option("--skipsystem",
                  action="store_true",
                  dest="skipsystem",
                  default=False,
                  help="Skip all unmodified system files in the backup "
                  "[default: %default]")
parser.add_option("--maxbackups",
                  action="store",
                  type="int",
                  dest="maxbackups",
                  default=8,
                  help="Number of levels deep for tower of hanoi "
                  "[default: %default]")
parser.add_option("--credits",
                  action="callback", callback=print_credits,
                  help="Print credits")

(options, args) = parser.parse_args()

if len(args)<1:
  print("Error: You must specify a <dest> and at least one <src>")
  parser.print_help()
  myexitcode()

if len(args)<2:
  print("Error: You must specify at least one source path")
  parser.print_help()
  myexitcode()

dest=args[0]
srcs=args[1:]

print("  DEBUG {0} => {1}".format(srcs,dest))

# Spinner function -----------------------------------------------------------

SPINNER_CHAR=['-','\\','|','/']
SPINNER_CHAR_POS=0
def spin():
    global SPINNER_CHAR, SPINNER_CHAR_POS
    sys.stdout.write(SPINNER_CHAR[SPINNER_CHAR_POS] + '\r')
    sys.stdout.flush()
    SPINNER_CHAR_POS+=1
    if SPINNER_CHAR_POS==4: SPINNER_CHAR_POS=0

# Verify that we are running as root -----------------------------------------

#if os.geteuid()!=0:
#  print("backsnap will only run as root.")
#  myexitcode()

# TEMP DIR -------------------------------------------------------------------

import tempfile
tempdir = tempfile.mkdtemp()

ONEXIT.append("""import shutil
print("Cleaning up {0}".format(globals()["tempdir"]))
shutil.rmtree(globals()["tempdir"])
"""
              );

# DETERMINE DIRECTION --------------------------------------------------------

# local: both are local
# push: remote destination
# pull: remote sources

import re
direction="local"
hostmatchprog = re.compile(r"^([^/]+):(.+)")
testdest = hostmatchprog.match(dest)
testsrc = hostmatchprog.match(srcs[0])
if testdest is not None:
  if testsrc is not None:
    print("Error: <dest> and <src> cannot both be remote")
    parser.print_help()
    myexitcode()
  else:                                    # PUSH:
    direction="push"
    desthost = testdest.groups()[0]
    destpath = testdest.groups()[1]
    destaccess = ['/usr/bin/ssh',desthost]
else:
  destaccess = []
  if testsrc is not None:                  # PULL:
    direction="pull"
    srcshost = testsrc.groups()[0]
    srcspath = []
    for s in srcs:
      ts = hostmatchprog.match(s)
      if ts.groups()[0] != testsrc.groups()[0]:
        print("Error: All remote <src> must be the same host")
        parser.print_help()
        myexitcode()
      srcspath.append(ts.groups()[1])
  else:                                    # LOCAL:
    direction="local"

print("  DEBUG: direction = {0}".format(direction))

# Get the excludes file into tempdir -----------------------------------------
import subprocess
if direction=="push":  # Deal with remote excludes file
  p = subprocess.Popen(['/usr/bin/ionice','-c','3',
                        '/usr/bin/scp',
                        "{0}:{1}/.backsnap/excludes".format(desthost,destpath),
                        tempdir],
                       stderr=subprocess.PIPE)
  sts = os.waitpid(p.pid,0)[1]
else:
  p = subprocess.Popen(['/bin/cp',"{0}/.backsnap/excludes".format(dest),
                        tempdir])
  sts = os.waitpid(p.pid,0)[1]
if (sts!=0):
  print("Error: excludes file out found at {0}/.backsnap/excludes".format(dest))
  myexitcode()
excludesfile=tempdir+"/excludes"

# Setup perfopts -------------------------------------------------------------
perfopts=''
if options.slownet:
  perfopts='-z'   # -z means compress
if direction=='local':
  perfopts='-W'   # -W copies the whole file, doesn't do delta algorithm
  # bash backsnap used -W on all fastnets, I'm not so sure about that.

# Setup RSYNC_RSH env --------------------------------------------------------
myenv = os.environ
if not direction=='local':
  # RSYNC_RSH environment variable will be used by rsync
  #   -c arcfour:         weak but fast encryption
  #   -o Compression=no:  rsync already compresses, ssh doesn't need to
  #   -x                  turns off X tunnelling (shouldn't be on anyhow)
  myenv['RSYNC_SSH']="/usr/bin/ionice -c 3 /usr/bin/ssh -c arcfour -o Compression=no -x"
else:
  myenv['RSYNC_SSH']=""

# Verify destination exists --------------------------------------------------
p = subprocess.Popen(destaccess + ['/usr/bin/test','-d',destpath])
sts = os.waitpid(p.pid,0)[1]
if sts != 0:
  print("Error: Destination {0} not found".format(dest))
  myexitcode()

# Determine the rotation target ----------------------------------------------

p = subprocess.Popen(destaccess + ['/bin/cat',
                                   "{0}/.backsnap/count".format(destpath)],
                     stdout=subprocess.PIPE,stderr=subprocess.PIPE)
output = p.communicate()[0]
if p.returncode!=0 or len(output)<1:
  count=0
else:
  if isinstance(output,bytes):
    output = output.decode()
  count = int(output)

if count == 0:
  # Pre tower strategy, do last level once
  target='LEVEL{0}'.format(options.maxbackups)
else:
  modulus=1
  level=1
  while level<options.maxbackups:
    modulus=modulus*2
    mod=count % modulus
    if mod!=0:
      break
    level+=1
  target='LEVEL{0}'.format(level)

if len(target)<1:
  print("Error: target did not get set (this is a bug)")
  myexitcode()

# Validate src access prior to dest deletion ---------------------------------

if direction=='pull':
  sd=os.path.dirname(srcspath[0])
else:
  sd=os.path.dirname(srcs[0])

cmd=['/usr/bin/ionice','-c','3']
cmd.extend(['/usr/bin/rsync','--links','--perms','--times','--group','--owner',
        '--devices','--specials','--one-file-system','--sparse',
        '--numeric-ids'])
cmd.append(perfopts)
cmd.extend(['--dirs','--dry-run'])   # This is ALWAYS dry run
cmd.extend([srcs[0],"{0}/{1}".format(dest,target)])

if options.dryrun:
  print(*cmd,sep=" ")
  sts = 0
else:
  p = subprocess.Popen(cmd, env=myenv,
                       stdout=subprocess.PIPE, stderr=subprocess.PIPE)
  sts = os.waitpid(p.pid,0)[1]

if sts not in [0,6,21,23,24,25]:   # Errors acceptible for proceeding
  print("Error: dry-run failed.  Aborting (nothing has been deleted)")
  myexitcode()

# ----------------------------------------------------------------------------
# p = subprocess.Popen(,env=myenv)

# DEBUG EXIT EARLY -----------------------------------------------------------

print("  Debug: this script bailing out early.")
myexitcode()

MANIFESTFILE='{0}/files_to_backup'.format(tempdir)

# Write a data line to MANIFESTFILE (and update spinner visual)
def output(data):
    global MANIFESTFILE
    fid=open(MANIFESTFILE,'a')
    fid.write("%s\n" % data)
    fid.close()
    spin()

#fid=open('/var/db/pkgs.dict','w')
#pickle.dump(PKGS,fid)
#fid.close()
#
#fid=open('/var/db/pkgs.dict','r')
#PKGS=pickle.load(fid)
#fid.close()

